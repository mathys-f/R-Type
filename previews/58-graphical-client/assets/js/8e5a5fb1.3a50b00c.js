"use strict";(globalThis.webpackChunkr_type=globalThis.webpackChunkr_type||[]).push([[482],{8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>l});var r=n(6540);const a={},s=r.createContext(a);function t(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),r.createElement(s.Provider,{value:i},e.children)}},8661:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"setup/technical-choices","title":"Technical Choices","description":"This document explains the main technical choices made in the project: the package manager (CPM) and the graphics library (raylib). It summarizes the rationale, alternatives considered, and build/maintenance implications.","source":"@site/docs/setup/technical-choices.md","sourceDirName":"setup","slug":"/setup/technical-choices","permalink":"/R-Type/previews/58-graphical-client/setup/technical-choices","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Technical Choices","id":"technical-choices"},"sidebar":"setupSidebar","previous":{"title":"Repository Structure","permalink":"/R-Type/previews/58-graphical-client/setup/repository-structure"}}');var a=n(4848),s=n(8453);const t={title:"Technical Choices",id:"technical-choices"},l="Technical Choices",c={},o=[{value:"Package Manager: CPM",id:"package-manager-cpm",level:2},{value:"Alternatives Considered",id:"alternatives-considered",level:2},{value:"Graphics Library: raylib",id:"graphics-library-raylib",level:2},{value:"Alternatives Considered",id:"alternatives-considered-1",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"technical-choices",children:"Technical Choices"})}),"\n",(0,a.jsxs)(i.p,{children:["This document explains the main technical choices made in the project: the package manager (",(0,a.jsx)(i.code,{children:"CPM"}),") and the graphics library (",(0,a.jsx)(i.code,{children:"raylib"}),"). It summarizes the rationale, alternatives considered, and build/maintenance implications."]}),"\n",(0,a.jsx)(i.h2,{id:"package-manager-cpm",children:"Package Manager: CPM"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Why CPM:"})," CPM is a single-file CMake script that integrates directly into CMake-based projects. It was chosen because it fits naturally with our CMake build system and requires minimal additional tooling for contributors."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Benefits:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Simple integration: just include the ",(0,a.jsx)(i.code,{children:"CPM.cmake"})," helper in the CMake flow."]}),"\n",(0,a.jsx)(i.li,{children:"Reproducible dependency fetching using CMake's FetchContent-style behavior."}),"\n",(0,a.jsx)(i.li,{children:"No separate package manager or language-specific tooling to install."}),"\n",(0,a.jsx)(i.li,{children:"Works well with our CI/build environments which already run CMake."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Implications:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Dependencies are declared in CMake, keeping build configuration centralized."}),"\n",(0,a.jsx)(i.li,{children:"Contributors only need a working CMake toolchain to fetch and build third-party libs."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Conan:"})," A mature, decentralized C/C++ package manager with wide community adoption. It offers binary package distribution, versioning, and fine-grained dependency control. It integrates with CMake via helper tools (e.g., ",(0,a.jsx)(i.code,{children:"cmake-conan"}),") but requires contributors to install and manage an external tool, which adds setup overhead and CI changes compared to a single-file CMake approach."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"vcpkg:"})," Microsoft's ",(0,a.jsx)(i.code,{children:"vcpkg"})," provides a curated set of portable C/C++ libraries and integrates with CMake through a toolchain file. It simplifies cross-platform builds (especially on Windows) and can provide prebuilt binaries, but it introduces an additional dependency and workflow outside of CMake's native flow and can be less flexible for non-standard or cutting-edge dependency versions."]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"graphics-library-raylib",children:"Graphics Library: raylib"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Why raylib:"})," raylib is designed specifically for game development, emphasizing simplicity and rapid iteration. It provides a lightweight, game-friendly API for graphics, input, audio, and textures, which makes it a good fit for an educational and prototype-friendly game project like this one."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Benefits:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Easy to learn and use: concise C API that maps well to typical game loop code."}),"\n",(0,a.jsx)(i.li,{children:"Lightweight and performant for 2D/3D game use-cases common to this project."}),"\n",(0,a.jsx)(i.li,{children:"Good cross-platform support, which simplifies development on Linux/macOS/Windows."}),"\n",(0,a.jsx)(i.li,{children:"Provides built-in helpers for textures, audio, input handling and basic 2D/3D rendering."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Implications:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"The repo already includes raylib sources and/or subbuild artifacts under the build tree, so CI and local builds will compile or reuse the integrated raylib as part of the normal CMake build."}),"\n",(0,a.jsx)(i.li,{children:"Game-specific features (sprites, audio playback, input polling) are simpler to implement and maintain with raylib compared to more general-purpose GUI libraries."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"alternatives-considered-1",children:"Alternatives Considered"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"SDL2 / SDL + SDL_image / SDL_mixer:"})," Very mature and flexible. More low-level; useful for broad multimedia needs. Chosen raylib instead because raylib offers a higher-level, game-focused API which speeds development."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"SFML:"})," Also game-friendly and C++-oriented. We preferred raylib for its minimal C API, small footprint, and the ease of integrating simple game loops."]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(i.p,{children:"We chose CPM for its seamless integration with CMake and low contributor overhead, and raylib for its game-focused, lightweight API and rapid development benefits. These choices prioritize fast iteration, simple contributor setup, and keeping build configuration centralized in CMake."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);