"use strict";(globalThis.webpackChunkr_type=globalThis.webpackChunkr_type||[]).push([[295],{728:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"networking/implementation-details","title":"Implementation Details","description":"This page provides a compact API reference for the networking module. Focused on the public types, functions, and methods you will call from client/server code.","source":"@site/docs/networking/implementation-details.md","sourceDirName":"networking","slug":"/networking/implementation-details","permalink":"/R-Type/previews/settings_menu/networking/implementation-details","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Implementation Details","id":"implementation-details"},"sidebar":"networkingSidebar","previous":{"title":"Flowcharts","permalink":"/R-Type/previews/settings_menu/networking/flowcharts"}}');var c=s(4848),t=s(8453);const d={title:"Implementation Details",id:"implementation-details"},r="Networking API Reference (concise)",l={},o=[];function a(e){const n={code:"code",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"networking-api-reference-concise",children:"Networking API Reference (concise)"})}),"\n",(0,c.jsx)(n.p,{children:"This page provides a compact API reference for the networking module. Focused on the public types, functions, and methods you will call from client/server code."}),"\n",(0,c.jsxs)(n.p,{children:["Source: ",(0,c.jsx)(n.code,{children:"src/networking/rtp/networking.h"}),", ",(0,c.jsx)(n.code,{children:"src/networking/rtp/*.cpp"}),", ",(0,c.jsx)(n.code,{children:"src/networking/handshake/*"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"Packet & header"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"struct PacketHeader"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Fields: ",(0,c.jsx)(n.code,{children:"m_magic"}),", ",(0,c.jsx)(n.code,{children:"m_command"}),", ",(0,c.jsx)(n.code,{children:"m_flags"}),", ",(0,c.jsx)(n.code,{children:"m_sequence"}),", ",(0,c.jsx)(n.code,{children:"m_ack"}),", ",(0,c.jsx)(n.code,{children:"m_fragment_id"}),", ",(0,c.jsx)(n.code,{children:"m_fragment_index"}),", ",(0,c.jsx)(n.code,{children:"m_fragment_count"}),", ",(0,c.jsx)(n.code,{children:"m_payload_size"}),", ",(0,c.jsx)(n.code,{children:"m_checksum"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"std::array<uint8_t, k_header_size> serialize() const"})," \u2014 produce header bytes (little-endian)."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"static PacketHeader deserialize(std::span<const uint8_t, k_header_size>)"})," \u2014 parse header and validate magic/payload size."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"struct Packet"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Fields: ",(0,c.jsx)(n.code,{children:"PacketHeader header"}),", ",(0,c.jsx)(n.code,{children:"std::vector<std::byte> payload"})," (raw payload bytes stored as ",(0,c.jsx)(n.code,{children:"std::byte"}),")."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"std::vector<uint8_t> to_buffer() const"})," \u2014 serialize header+payload into the on-wire ",(0,c.jsx)(n.code,{children:"uint8_t"})," buffer and compute CRC."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"static Packet from_buffer(std::span<const uint8_t>)"})," \u2014 parse full packet from an on-wire ",(0,c.jsx)(n.code,{children:"uint8_t"})," buffer and validate checksum."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Enums & flags"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"enum class CommandId : uint8_t"})," \u2014 command identifiers (e.g. ",(0,c.jsx)(n.code,{children:"KReqLogin"}),", ",(0,c.jsx)(n.code,{children:"KResLogin"}),", ",(0,c.jsx)(n.code,{children:"KClientInput"}),", ",(0,c.jsx)(n.code,{children:"KServerEntityState"}),", ",(0,c.jsx)(n.code,{children:"KAck"}),")."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"enum class PacketFlag : uint8_t"})," \u2014 ",(0,c.jsx)(n.code,{children:"KReliable"}),", ",(0,c.jsx)(n.code,{children:"KFragment"}),", ",(0,c.jsx)(n.code,{children:"KAck"}),", ",(0,c.jsx)(n.code,{children:"KError"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:["Helpers: ",(0,c.jsx)(n.code,{children:"has_flag(uint8_t mask, PacketFlag)"}),", ",(0,c.jsx)(n.code,{children:"set_flag(uint8_t mask, PacketFlag)"}),", ",(0,c.jsx)(n.code,{children:"clear_flag(...)"})," and bitwise operators."]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Reliability primitives"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"struct ReliabilityConfig"})," \u2014 parameters: ",(0,c.jsx)(n.code,{children:"max_retransmissions"}),", ",(0,c.jsx)(n.code,{children:"initial_rto"}),", ",(0,c.jsx)(n.code,{children:"max_rto"}),", ",(0,c.jsx)(n.code,{children:"window_size"}),"."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"class ReliableSendQueue"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Constructor: ",(0,c.jsx)(n.code,{children:"ReliableSendQueue(ReliabilityConfig config = {})"})]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"uint32_t next_sequence()"})," \u2014 returns next sequence id (increments counter)."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void track(const Packet& packet, time_point now)"})," \u2014 start tracking a sent reliable packet."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void acknowledge(uint32_t ackId)"})," \u2014 remove packets up to ",(0,c.jsx)(n.code,{children:"ackId"})," from the queue."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"std::vector<Packet> collect_timeouts(time_point now)"})," \u2014 return packets that need retransmission."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"optional<milliseconds> time_until_next_timeout(time_point now) const"})," \u2014 time until next retransmit."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"std::vector<uint32_t> take_failures()"})," \u2014 retrieve sequences that exhausted retries."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"class ReliableReceiveWindow"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void observe(uint32_t sequence)"})," \u2014 update window with observed sequence."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"uint32_t ack() const noexcept"})," \u2014 get highest contiguous ack id."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Transport"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"class UdpTransport : enable_shared_from_this<UdpTransport>"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Constructor: ",(0,c.jsx)(n.code,{children:"UdpTransport(io_context&, uint16_t localPort = 0)"})," \u2014 bind UDP socket."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void set_default_remote(const udp::endpoint&)"})," \u2014 store default remote endpoint."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"bool has_default_remote() const noexcept"})," \u2014 check default endpoint."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"const udp::endpoint& default_remote() const"})," \u2014 get default endpoint (throws if not set)."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void start(PacketHandler handler)"})," \u2014 start async receive loop; ",(0,c.jsx)(n.code,{children:"PacketHandler"})," is ",(0,c.jsx)(n.code,{children:"function<void(const error_code&, Packet, const udp::endpoint&)>"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void async_send(const Packet& packet)"})," \u2014 send to default remote (throws if none)."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void async_send(const Packet& packet, const udp::endpoint& endpoint, SendHandler handler = {})"})," \u2014 send to endpoint; ",(0,c.jsx)(n.code,{children:"SendHandler"})," is ",(0,c.jsx)(n.code,{children:"function<void(const error_code&, const Packet&)>"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void close()"})," \u2014 close socket and stop receives."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Session (high-level)"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"class Session : enable_shared_from_this<Session>"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Constructor: ",(0,c.jsx)(n.code,{children:"Session(io_context&, const udp::endpoint& remote, ReliabilityConfig config = {}, uint16_t localPort = 0)"})," \u2014 creates ",(0,c.jsx)(n.code,{children:"UdpTransport"}),", configures remote."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"using PacketCallback = function<void(const Packet&, const udp::endpoint&)>"})," \u2014 callback type."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void start(PacketCallback onReliable, PacketCallback onUnreliable)"})," \u2014 begin receiving and enable retransmit timers."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void send(Packet packet, bool reliable = false)"})," \u2014 send to configured default remote."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void send(Packet packet, const udp::endpoint& endpoint, bool reliable = false)"})," \u2014 send to explicit endpoint."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void set_fragment_payload_size(size_t)"})," / ",(0,c.jsx)(n.code,{children:"size_t fragment_payload_size() const"})," \u2014 set/get negotiated fragment payload size."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"void poll()"})," \u2014 check retransmissions and send due packets (also invoked by internal timer)."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"const std::vector<uint32_t>& failed_sequences() const noexcept"})," \u2014 sequences that exhausted retries."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["Handshake helpers (namespace ",(0,c.jsx)(n.code,{children:"net::handshake"}),")"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"struct ReqLogin { string m_username; uint32_t m_version; uint16_t m_preferred_fragment_size; }"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"struct ResLogin { bool m_success; uint32_t m_player_id; uint16_t m_effective_fragment_size; }"})}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Packet make_req_login(const ReqLogin&)"})," \u2014 build REQ_LOGIN packet payload."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Packet make_res_login(const ResLogin&)"})," \u2014 build RES_LOGIN packet payload."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"optional<ReqLogin> parse_req_login(const Packet&)"})," \u2014 parse and validate REQ_LOGIN."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"optional<ResLogin> parse_res_login(const Packet&)"})," \u2014 parse and validate RES_LOGIN."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"bool handle_server_handshake(const Packet& packet, const shared_ptr<Session>& session, const udp::endpoint& endpoint)"})," \u2014 convenience: parse incoming REQ_LOGIN, set fragment size, send RES_LOGIN (returns true when handled)."]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Quick usage notes"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["To receive reliable messages: call ",(0,c.jsx)(n.code,{children:"session->start(onReliableCallback, onUnreliableCallback)"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:["To send reliably: set ",(0,c.jsx)(n.code,{children:"packet.header.m_flags"})," to include ",(0,c.jsx)(n.code,{children:"KReliable"})," or call ",(0,c.jsx)(n.code,{children:"session->send(packet, true)"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:["For large payloads: ",(0,c.jsx)(n.code,{children:"Session"})," will fragment automatically (fragments are always sent reliably)."]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Where to look in code"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"src/networking/rtp/networking.h"})," \u2014 primary API types and method signatures."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"src/networking/rtp/packet.cpp"})," \u2014 serialization and checksum behavior."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"src/networking/rtp/reliability.cpp"})," \u2014 retransmission and window logic."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"src/networking/rtp/session.cpp"})," \u2014 session behavior, fragmentation, and callbacks."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"src/networking/handshake/*"})," \u2014 login handshake helpers."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>r});var i=s(6540);const c={},t=i.createContext(c);function d(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);